module ActionMonotonicity where

open import Agda.Builtin.Nat
open import Agda.Builtin.Equality
open import KernelAlgebra
open import Agda.Builtin.Nat using (Nat)
open import Data.Nat.Base using (_≤_)


------------------------------------------------------------------------
-- Action functional

record Action {X : Set} : Set₁ where
  field
    A : State X → Nat

open Action public

------------------------------------------------------------------------
-- Monotonicity property

record Monotone {X : Set}
                (K : State X → State X)
                (A : State X → Nat)
                : Set where

  field
    monotone :
      ∀ s → A (K s) ≤ A s
module AntiFascistSystem where

open import Level
open import Data.Nat
open import Relation.Nullary using (¬_)
open import Relation.Binary.PropositionalEquality

postulate
  S : Set
  H : S → ℕ

-- Invertible operator

record Invertible : Set where
  field
    U    : S → S
    U⁻¹  : S → S
    left  : ∀ s → U⁻¹ (U s) ≡ s
    right : ∀ s → U (U⁻¹ s) ≡ s

-- Entropy preserved under unitary-like operator

postulate
  entropy-preserved :
    ∀ (u : Invertible) s → H (Invertible.U u s) ≡ H s

-- No monotone collapse

postulate
  non-collapse :
    ∀ (u : Invertible) → ¬ (∀ s → H (Invertible.U u s) ≤ H s)
module Base369 where

open import Agda.Builtin.Equality
open import Agda.Builtin.Nat

------------------------------------------------------------------------
-- Utility: repeated rotation
------------------------------------------------------------------------

spin : {A : Set} → Nat → (A → A) → A → A
spin 0       rot x = x
spin (suc n) rot x = rot (spin n rot x)

------------------------------------------------------------------------
-- Truth values
------------------------------------------------------------------------

data TriTruth : Set where
  tri-low  : TriTruth
  tri-mid  : TriTruth
  tri-high : TriTruth

tri-index : TriTruth → Nat
tri-index tri-low  = 0
tri-index tri-mid  = 1
tri-index tri-high = 2

rotateTri : TriTruth → TriTruth
rotateTri tri-low  = tri-mid
rotateTri tri-mid  = tri-high
rotateTri tri-high = tri-low

triXor : TriTruth → TriTruth → TriTruth
triXor carrier target = spin (tri-index carrier) rotateTri target

rotateTri³ : ∀ t → rotateTri (rotateTri (rotateTri t)) ≡ t
rotateTri³ tri-low  = refl
rotateTri³ tri-mid  = refl
rotateTri³ tri-high = refl

triXor-identityˡ : ∀ t → triXor tri-low t ≡ t
triXor-identityˡ _ = refl

triXor-assoc : ∀ a b c → triXor a (triXor b c) ≡ triXor (triXor a b) c
triXor-assoc tri-low  _        _ = refl
triXor-assoc tri-mid  tri-low  c = refl
triXor-assoc tri-mid  tri-mid  c = refl
triXor-assoc tri-mid  tri-high c rewrite rotateTri³ c = refl
triXor-assoc tri-high tri-low  c rewrite rotateTri³ c = refl
triXor-assoc tri-high tri-mid  c rewrite rotateTri³ c = refl
triXor-assoc tri-high tri-high c rewrite rotateTri³ c = refl

------------------------------------------------------------------------

-- A hexadic universe: six “beats” that wrap around.

data HexTruth : Set where
  hex-0 hex-1 hex-2 hex-3 hex-4 hex-5 : HexTruth

hex-index : HexTruth → Nat
hex-index hex-0 = 0
hex-index hex-1 = 1
hex-index hex-2 = 2
hex-index hex-3 = 3
hex-index hex-4 = 4
hex-index hex-5 = 5

rotateHex : HexTruth → HexTruth
rotateHex hex-0 = hex-1
rotateHex hex-1 = hex-2
rotateHex hex-2 = hex-3
rotateHex hex-3 = hex-4
rotateHex hex-4 = hex-5
rotateHex hex-5 = hex-0

hexXor : HexTruth → HexTruth → HexTruth
hexXor carrier target = spin (hex-index carrier) rotateHex target

rotateHex⁶ : ∀ h → spin 6 rotateHex h ≡ h
rotateHex⁶ hex-0 = refl
rotateHex⁶ hex-1 = refl
rotateHex⁶ hex-2 = refl
rotateHex⁶ hex-3 = refl
rotateHex⁶ hex-4 = refl
rotateHex⁶ hex-5 = refl

hexXor-identityˡ : ∀ h → hexXor hex-0 h ≡ h
hexXor-identityˡ _ = refl

------------------------------------------------------------------------

-- A nonary universe: nine “voxels” in a ring.

data NonaryTruth : Set where
  non-0 non-1 non-2 non-3 non-4 non-5 non-6 non-7 non-8 : NonaryTruth

nonary-index : NonaryTruth → Nat
nonary-index non-0 = 0
nonary-index non-1 = 1
nonary-index non-2 = 2
nonary-index non-3 = 3
nonary-index non-4 = 4
nonary-index non-5 = 5
nonary-index non-6 = 6
nonary-index non-7 = 7
nonary-index non-8 = 8

rotateNonary : NonaryTruth → NonaryTruth
rotateNonary non-0 = non-1
rotateNonary non-1 = non-2
rotateNonary non-2 = non-3
rotateNonary non-3 = non-4
rotateNonary non-4 = non-5
rotateNonary non-5 = non-6
rotateNonary non-6 = non-7
rotateNonary non-7 = non-8
rotateNonary non-8 = non-0

nonaryXor : NonaryTruth → NonaryTruth → NonaryTruth
nonaryXor carrier target = spin (nonary-index carrier) rotateNonary target

rotateNonary⁹ : ∀ n → spin 9 rotateNonary n ≡ n
rotateNonary⁹ non-0 = refl
rotateNonary⁹ non-1 = refl
rotateNonary⁹ non-2 = refl
rotateNonary⁹ non-3 = refl
rotateNonary⁹ non-4 = refl
rotateNonary⁹ non-5 = refl
rotateNonary⁹ non-6 = refl
rotateNonary⁹ non-7 = refl
rotateNonary⁹ non-8 = refl

nonaryXor-identityˡ : ∀ n → nonaryXor non-0 n ≡ n
nonaryXor-identityˡ _ = refl
module Contraction where

open import Agda.Builtin.Equality
open import Data.Nat using (_<_)
open import Ultrametric as UMetric


------------------------------------------------------------------------
-- Contraction property (strict)

record Contractive
       {S : Set}
       (U : UMetric.Ultrametric S)
       (K : S → S)
       : Set where

  open UMetric.Ultrametric U

  field
    contraction :
      ∀ x y →
      d (K x) (K y) < d x y
module CounterexampleHarness where

open import Agda.Builtin.Sigma
open import Agda.Builtin.Equality
open import Relation.Nullary.Negation using (¬_)


------------------------------------------------------------------------
-- Generic falsifier

record Counterexample {A : Set}
                      (P : A → Set)
                      : Set₁ where
  field
    witness : A
    violates : ¬ P witness
module DASHI_Tests where

open import Agda.Builtin.Equality
open import Agda.Builtin.Nat
open import Agda.Builtin.Sigma using (Σ; _,_)

open import Base369
open import LogicTlurey
open import KernelAlgebra
open import Ultrametric
open import Contraction
open import ActionMonotonicity

------------------------------------------------------------------------
-- Base369 regression tests
------------------------------------------------------------------------

rotateTri³-id : ∀ t → spin 3 rotateTri t ≡ t
rotateTri³-id tri-low  = refl
rotateTri³-id tri-mid  = refl
rotateTri³-id tri-high = refl

triXor-comm : ∀ a b → triXor a b ≡ triXor b a
triXor-comm tri-low  tri-low  = refl
triXor-comm tri-low  tri-mid  = refl
triXor-comm tri-low  tri-high = refl
triXor-comm tri-mid  tri-low  = refl
triXor-comm tri-mid  tri-mid  = refl
triXor-comm tri-mid  tri-high = refl
triXor-comm tri-high tri-low  = refl
triXor-comm tri-high tri-mid  = refl
triXor-comm tri-high tri-high = refl

------------------------------------------------------------------------
-- Tlurey trace tests
------------------------------------------------------------------------

-- The stage transition is 4-periodic.
next⁴-test : ∀ s → spin 4 next s ≡ s
next⁴-test = next⁴

trace-len-test : ∀ n s → length (StageTrace n s) ≡ n
trace-len-test = StageTrace-length

------------------------------------------------------------------------
-- Kernel algebra tests
------------------------------------------------------------------------

-- A concrete "kernel" instance: identity update.
K-id : ∀ {X : Set} → Kernel {X}
K-id {X} = record
  { K = λ s → s
  ; involutive-respecting = λ s → refl
  }

-- Another concrete kernel: pointwise involution.
K-neg : ∀ {X : Set} → Kernel {X}
K-neg {X} = record
  { K = ι
  ; involutive-respecting = λ s → refl
  }

-- Sanity: K-neg applied twice is identity (pointwise).
K-neg2-pointwise : ∀ {X : Set} (s : State X) (x : X) →
  Kernel.K (K-neg {X}) (Kernel.K (K-neg {X}) s) x ≡ s x
K-neg2-pointwise s x = ι²-id s x

------------------------------------------------------------------------
-- Contraction / monotone-action interface smoke tests
------------------------------------------------------------------------

-- We only check that the exposed interfaces are callable.

postulate
  X : Set
  U : Ultrametric X
  f : X → X
  cf : Contractive U f
  x y : X

contraction-smoke = Contractive.contraction cf x y

postulate
  X1 : Set
  K1 : State X1 → State X1
  A1 : State X1 → Nat
  M : Monotone K1 A1
  s1 : State X1

monotone-smoke = Monotone.monotone M s1
module Fascism_Tests where

open import Agda.Builtin.Equality
open import Agda.Builtin.Nat
open import Agda.Builtin.Sigma using (Σ; _,_)

open import FascisticSystem
open import AntiFascistSystem
-- Smoke tests: current interfaces and postulated theorems remain callable.

postulate
  sF : FascisticSystem.S
  uA : AntiFascistSystem.Invertible
  sA : AntiFascistSystem.S

fascism-monotone-smoke = FascisticSystem.monotone sF

fascism-strict-decrease-smoke = FascisticSystem.strict-decrease sF

anti-entropy-preserved-smoke = AntiFascistSystem.entropy-preserved uA sA

anti-non-collapse-smoke = AntiFascistSystem.non-collapse uA

-- Interface-level comparison hook to quantum: unitary evolution should be invertible,
-- so it cannot satisfy the projection-only + strict contraction hypotheses simultaneously.
-- We keep this as a spec-level test (type only).

postulate
  QState : Set
  UQ : QState → QState

unitary-is-invertible : Set
unitary-is-invertible = Σ (QState → QState) (λ inv → (∀ x → inv (UQ x) ≡ x) × (∀ x → UQ (inv x) ≡ x))
  where
    infixr 4 _×_
    record _×_ (A B : Set) : Set where
      constructor _,_
      field fst : A
            snd : B
module FascisticSystem where

open import Data.Product using (Σ; _,_)
open import Data.Sum using (_⊎_; inj₁; inj₂)
open import Relation.Binary.PropositionalEquality using (_≡_)

open import Data.Nat as Nat
open import Data.Bool using (Bool; true; false)



-- Abstract finite state space

postulate
  S : Set
  finiteS : ℕ          -- cardinality (not constructively used)

-- Entropy function (measure into ℕ for simplicity)

postulate
  H : S → ℕ

-- Projection operator (idempotent, non-invertible)

record Projection : Set where
  field
    K        : S → S
    idemp    : ∀ s → K (K s) ≡ K s
    contract : ∀ s → H (K s) ≤ H s

-- System = list of projections applied in fixed order

postulate
  Ktotal : S → S

-- Global contraction property

postulate
  monotone : ∀ s → H (Ktotal s) ≤ H s

-- Strict decrease when not in fixed set

postulate
  strict-decrease :
    ∀ s → H (Ktotal s) < H s ⊎ (Ktotal s ≡ s)

-- Define attractor

Attractor : Set
Attractor = Σ S (λ s → Ktotal s ≡ s)

-- Iteration

iterate : ℕ → S → S
iterate zero    s = s
iterate (suc n) s = Ktotal (iterate n s)
module FixedPoint where

open import Agda.Builtin.Nat
open import Agda.Builtin.Equality
open import Ultrametric as UMetric
open import Contraction

------------------------------------------------------------------------
-- Fixed point definition

Fixed : {S : Set} → (S → S) → S → Set
Fixed K x = K x ≡ x

------------------------------------------------------------------------
-- Uniqueness of fixed point under contraction

record UniqueFixed
       {S : Set}
       (U : UMetric.Ultrametric S)
       (K : S → S)
       (C : Contractive U K)
       : Set where

  open UMetric.Ultrametric U
  open Contractive C

  field
    unique :
      ∀ x y →
      Fixed K x →
      Fixed K y →
      x ≡ y
module KernelAlgebra where

open import Agda.Builtin.Equality
open import Agda.Builtin.Sigma
open import Agda.Builtin.Bool
open import Agda.Builtin.Nat

------------------------------------------------------------------------
-- Base ternary carrier

data T : Set where
  neg  : T
  zero : T
  pos  : T

------------------------------------------------------------------------
-- State space as indexed function

State : Set → Set
State X = X → T

------------------------------------------------------------------------
-- Involution

ι : ∀ {X} → State X → State X
ι s x with s x
... | neg  = pos
... | pos  = neg
... | zero = zero

ι²-id : ∀ {X} (s : State X) (x : X) → ι (ι s) x ≡ s x
ι²-id s x with s x
... | neg  = refl
... | pos  = refl
... | zero = refl


------------------------------------------------------------------------
-- Kernel operator interface

record Kernel {X : Set} : Set₁ where
  field
    K : State X → State X

    involutive-respecting :
      ∀ s → K (ι s) ≡ ι (K s)

open Kernel public
module LogicTlurey where

open import Agda.Builtin.Equality
open import Agda.Builtin.List
open import Agda.Builtin.Nat

------------------------------------------------------------------------
-- Local equality utilities (no stdlib needed)
------------------------------------------------------------------------

sym : ∀ {A : Set} {x y : A} → x ≡ y → y ≡ x
sym refl = refl

cong : ∀ {A B : Set} {x y : A} (f : A → B) → x ≡ y → f x ≡ f y
cong f refl = refl

open import Base369

------------------------------------------------------------------------
-- Dialectical stages
------------------------------------------------------------------------

data Stage : Set where
  seed      : Stage
  counter   : Stage
  resonance : Stage
  overflow  : Stage

next : Stage → Stage
next seed      = counter
next counter   = resonance
next resonance = overflow
next overflow  = seed

------------------------------------------------------------------------
-- Tlurey traces
------------------------------------------------------------------------

StageTrace : Nat → Stage → List Stage
StageTrace zero    _ = []
StageTrace (suc n) s = s ∷ StageTrace n (next s)

length : ∀ {A : Set} → List A → Nat
length []       = zero
length (_ ∷ xs) = suc (length xs)

_++_ : ∀ {A : Set} → List A → List A → List A
[]       ++ ys = ys
(x ∷ xs) ++ ys = x ∷ (xs ++ ys)

StageTrace-length : ∀ n s → length (StageTrace n s) ≡ n
StageTrace-length zero    _ = refl
StageTrace-length (suc n) s = cong suc (StageTrace-length n (next s))

next⁴ : ∀ s → spin 4 next s ≡ s
next⁴ seed      = refl
next⁴ counter   = refl
next⁴ resonance = refl
next⁴ overflow  = refl

spin-next-succ : ∀ n s → spin n next (next s) ≡ spin (suc n) next s
spin-next-succ zero    _ = refl
spin-next-succ (suc n) s = cong next (spin-next-succ n s)

StageTrace-periodic : ∀ n s → StageTrace (n + 4) s ≡ StageTrace n s ++ StageTrace 4 (spin n next s)
StageTrace-periodic zero    s = refl
StageTrace-periodic (suc n) s rewrite sym (spin-next-succ n s) =
  cong (s ∷_) (StageTrace-periodic n (next s))

StageTrace-cycle : ∀ n → StageTrace (n + 4) seed ≡ StageTrace n seed ++ StageTrace 4 (spin n next seed)
StageTrace-cycle n = StageTrace-periodic n seed


------------------------------------------------------------------------
-- Semantics via triadic values
------------------------------------------------------------------------

stageTone : Stage → TriTruth
stageTone seed      = tri-low
stageTone counter   = tri-mid
stageTone resonance = tri-high
stageTone overflow  = tri-low

combineStage : Stage → Stage → TriTruth
combineStage a b = triXor (stageTone a) (stageTone b)

stageTone-next-seed : stageTone (next seed) ≡ rotateTri (stageTone seed)
stageTone-next-seed = refl

stageTone-next-counter : stageTone (next counter) ≡ rotateTri (stageTone counter)
stageTone-next-counter = refl

stageTone-next-resonance : stageTone (next resonance) ≡ rotateTri (stageTone resonance)
stageTone-next-resonance = refl

stageTone-next-overflow : stageTone (next overflow) ≡ stageTone seed
stageTone-next-overflow = refl

resonance-combine : combineStage resonance resonance ≡ tri-mid
resonance-combine = refl
module OperatorMonoid where

open import Agda.Builtin.Equality
open import KernelAlgebra

------------------------------------------------------------------------
-- Endomorphism

Endo : ∀ {X} → Set
Endo {X} = State X → State X

------------------------------------------------------------------------
-- Composition

_∘_ : ∀ {X} → Endo {X} → Endo {X} → Endo {X}
(f ∘ g) s = f (g s)

------------------------------------------------------------------------
-- Closure under composition

record Generated {X : Set}
                 (K : Endo {X})
                 : Set where

  field
    closed :
      ∀ (f g : Endo {X}) → Endo {X}
module Overflow where

open import Agda.Builtin.Equality
open import Agda.Builtin.Nat using (Nat ; zero ; suc)

------------------------------------------------------------------------
-- Local congruence lemma (no stdlib needed)
------------------------------------------------------------------------

congOverflow : ∀ {A B : Set} {x y : A} (f : A → B) → x ≡ y → f x ≡ f y
congOverflow f refl = refl

------------------------------------------------------------------------
-- Basic relations on ℕ (custom strict order)
------------------------------------------------------------------------

infix 4 _≺_

data _≺_ : Nat → Nat → Set where
  z≺s : ∀ {n} → zero ≺ suc n
  s≺s : ∀ {m n} → m ≺ n → suc m ≺ suc n

------------------------------------------------------------------------
-- Voxel states
------------------------------------------------------------------------

data Voxel : Set where
  grounded plateau ascended : Voxel

------------------------------------------------------------------------
-- Threshold guards with explicit proofs
------------------------------------------------------------------------

-- Each constructor carries the witness required to justify the
-- classification relative to the threshold.
data VoxelGuard (threshold value : Nat) : Set where
  stay   : value ≺ threshold → VoxelGuard threshold value
  pivot  : threshold ≡ value → VoxelGuard threshold value
  ascend : threshold ≺ value → VoxelGuard threshold value

state : ∀ {t v} → VoxelGuard t v → Voxel
state (stay _)   = grounded
state (pivot _)  = plateau
state (ascend _) = ascended

------------------------------------------------------------------------
-- Helper: deterministically choose a guard by structural comparison
------------------------------------------------------------------------

data Order : Set where below equal above : Order

compare : Nat → Nat → Order
compare zero    zero    = equal
compare zero    (suc _) = below
compare (suc _) zero    = above
compare (suc a) (suc b) = compare a b

------------------------------------------------------------------------
-- Relations exposed by comparison tokens
------------------------------------------------------------------------

compare-below→≺ : ∀ {t v} → compare t v ≡ below → t ≺ v
compare-below→≺ {zero}   {zero}   ()
compare-below→≺ {zero}   {suc _}  refl = z≺s
compare-below→≺ {suc _}  {zero}   ()
compare-below→≺ {suc t}  {suc v}  pr   = s≺s (compare-below→≺ {t} {v} pr)

compare-above→≺ : ∀ {t v} → compare t v ≡ above → v ≺ t
compare-above→≺ {zero}   {zero}   ()
compare-above→≺ {zero}   {suc _}  ()
compare-above→≺ {suc _}  {zero}   refl = z≺s
compare-above→≺ {suc t}  {suc v}  pr   = s≺s (compare-above→≺ {t} {v} pr)

compare-equal→≡ : ∀ {t v} → compare t v ≡ equal → t ≡ v
compare-equal→≡ {zero}  {zero}  refl = refl
compare-equal→≡ {zero}  {suc _} ()
compare-equal→≡ {suc _} {zero} ()
compare-equal→≡ {suc t} {suc v} pr = congOverflow suc (compare-equal→≡ {t} {v} pr)

compare-≺→below : ∀ {t v} → t ≺ v → compare t v ≡ below
compare-≺→below z≺s      = refl
compare-≺→below (s≺s p)  = compare-≺→below p

compare-roundtrip-below : ∀ {t v} (p : t ≺ v) → compare-below→≺ (compare-≺→below p) ≡ p
compare-roundtrip-below z≺s      = refl
compare-roundtrip-below (s≺s p)  = congOverflow s≺s (compare-roundtrip-below p)

------------------------------------------------------------------------
-- Enforcement by comparison
------------------------------------------------------------------------


open import Relation.Binary.PropositionalEquality using (_≡_; refl)

enforce : (threshold value : Nat) → VoxelGuard threshold value
enforce zero    zero    = pivot refl
enforce zero    (suc v) = ascend z≺s
enforce (suc t) zero    = stay z≺s
enforce (suc t) (suc v) with enforce t v
... | stay p   = stay   (s≺s p)
... | pivot p  = pivot  (congOverflow suc p)
... | ascend p = ascend (s≺s p)


------------------------------------------------------------------------
-- Correctness of enforcement
------------------------------------------------------------------------

enforce-ascended-if : ∀ {t v} (p : t ≺ v) → enforce t v ≡ ascend p
enforce-ascended-if {zero}  {suc v} z≺s = refl
enforce-ascended-if {suc t} {suc v} (s≺s p) rewrite enforce-ascended-if {t} {v} p = refl

only-if : ∀ {t v} → state (enforce t v) ≡ ascended → t ≺ v
only-if {t} {v} with enforce t v
... | stay   _ = λ ()
... | pivot  _ = λ ()
... | ascend p = λ _ → p

------------------------------------------------------------------------
-- Extra comparison lemmas (if you still want them)
------------------------------------------------------------------------

compare-eq-below : ∀ {t v} → compare t v ≡ below → t ≺ v
compare-eq-below {zero}    {zero}    ()
compare-eq-below {zero}    {suc _}   refl = z≺s
compare-eq-below {suc _}   {zero}    ()
compare-eq-below {suc t}   {suc v}   p = s≺s (compare-eq-below {t} {v} p)

compare-eq-above : ∀ {t v} → compare t v ≡ above → v ≺ t
compare-eq-above {zero}    {zero}    ()
compare-eq-above {zero}    {suc _}   ()
compare-eq-above {suc _}   {zero}    refl = z≺s
compare-eq-above {suc t}   {suc v}   p = s≺s (compare-eq-above {t} {v} p)
module Stabilisation where

open import Agda.Builtin.Nat
open import Agda.Builtin.Equality
open import KernelAlgebra

------------------------------------------------------------------------
-- Iteration

iterate : ∀ {X} →
          (State X → State X) →
          Nat →
          State X →
          State X
iterate K zero    s = s
iterate K (suc n) s = iterate K n (K s)

------------------------------------------------------------------------
-- No nontrivial 2-cycle

No2Cycle : ∀ {X} (K : State X → State X) → Set
No2Cycle K =
  ∀ s → iterate K 2 s ≡ s → K s ≡ s
-- Agda: 10-Fold Way Bridges
module TenfoldBridges where

open import Data.Nat
open import Data.Bool
open import Relation.Binary.PropositionalEquality

-- Topological class
topoClass : ℕ → ℕ
topoClass n = n mod 10

-- Bridge record
record Bridge : Set where
  field
    nodeA : ℕ
    nodeB : ℕ
    different : topoClass nodeA ≢ topoClass nodeB

-- Symmetry
bridge-sym : (b : Bridge) → Bridge
bridge-sym record { nodeA = a ; nodeB = b ; different = d } =
  record { nodeA = b ; nodeB = a ; different = d ∘ sym }

-- Example: 232 ↔ 323
bridge-232-323 : Bridge
bridge-232-323 = record
  { nodeA = 232
  ; nodeB = 323
  ; different = λ ()
  }

-- Theorem: Symmetry preserves bridges
bridge-symmetry : (b : Bridge) → 
  Bridge.nodeA (bridge-sym b) ≡ Bridge.nodeB b
bridge-symmetry b = refl
module Ultrametric where

open import Data.Nat using (ℕ; _≤_; _<_)
open import Agda.Builtin.Equality
open import Agda.Builtin.Nat
open import Agda.Builtin.Sigma
open import Data.Nat using (ℕ; _⊔_)
max : ℕ → ℕ → ℕ
max = _⊔_


------------------------------------------------------------------------
-- Distance function into ℕ (discrete ultrametric)

record Ultrametric (S : Set) : Set₁ where
  field
    d : S → S → Nat

    -- Identity
    id-zero :
      ∀ x → d x x ≡ 0

    -- Symmetry
    symmetric :
      ∀ x y → d x y ≡ d y x

    -- Strong triangle inequality (ultrametric)
    ultratriangle :
      ∀ x y z →
      d x z ≤ max (d x y) (d y z)
